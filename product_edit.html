<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edycja produktu</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        background: linear-gradient(145deg, #f7f7f7, #e9ecf1);
        padding: 2rem 1rem 3rem;
      }

      main {
        width: min(960px, 100%);
        margin: 0 auto;
        background: #ffffff;
        border-radius: 24px;
        padding: clamp(1.75rem, 2vw + 1rem, 2.75rem) clamp(1.5rem, 2vw + 0.75rem, 3rem);
        box-shadow: 0 20px 55px rgba(15, 23, 42, 0.12);
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }

      .top-actions {
        display: flex;
        justify-content: flex-start;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1.15rem;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.12);
        color: #4338ca;
        font-weight: 600;
        text-decoration: none;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }

      .back-link:hover,
      .back-link:focus {
        background: rgba(99, 102, 241, 0.2);
        color: #312e81;
        transform: translateY(-1px);
        outline: none;
      }

      header {
        text-align: center;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.85rem, 2.2vw + 1.2rem, 2.6rem);
        color: #1f2937;
      }

      .subtitle {
        margin-top: 0.5rem;
        color: #4b5563;
        font-size: 1rem;
      }

      #status {
        margin: 0;
        padding: 1rem 1.25rem;
        border-radius: 14px;
        border: 1px solid rgba(99, 102, 241, 0.25);
        background: rgba(99, 102, 241, 0.06);
        color: #312e81;
        line-height: 1.5;
        transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
      }

      #status[data-status-type="error"] {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(254, 226, 226, 0.65);
        color: #991b1b;
      }

      #status[data-status-type="success"] {
        border-color: rgba(16, 185, 129, 0.35);
        background: rgba(209, 250, 229, 0.7);
        color: #065f46;
      }

      form {
        display: grid;
        gap: 1.5rem;
      }

      fieldset {
        border: 1px solid #e5e7eb;
        border-radius: 18px;
        padding: 1.25rem 1.5rem 1.5rem;
        background: #f9fafb;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      legend {
        font-weight: 600;
        color: #1f2937;
        padding: 0 0.5rem;
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      label {
        font-weight: 600;
        color: #111827;
      }

      input[type="text"],
      input[type="search"],
      textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid #d1d5db;
        padding: 0.85rem 1rem;
        font: inherit;
        color: #1f2937;
        background-color: #ffffff;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      }

      input[type="file"] {
        font: inherit;
      }

      .file-input {
        width: 100%;
        border-radius: 12px;
        border: 1px dashed #c7d2fe;
        padding: 0.75rem 1rem;
        background-color: #eef2ff;
        color: #312e81;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      }

      .file-input:focus {
        outline: none;
        border-color: #6366f1;
        box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.12);
        background-color: #e0e7ff;
      }

      .file-input::file-selector-button {
        border: none;
        border-radius: 999px;
        padding: 0.5rem 1.25rem;
        margin-right: 0.75rem;
        font: inherit;
        font-weight: 600;
        background: linear-gradient(120deg, #6366f1, #8b5cf6);
        color: #ffffff;
        cursor: pointer;
        transition: filter 0.2s ease, transform 0.2s ease;
      }

      .file-input::file-selector-button:hover,
      .file-input::file-selector-button:focus {
        filter: brightness(1.05);
        transform: translateY(-1px);
      }

      .hint {
        margin: 0;
        color: #6b7280;
        font-size: 0.875rem;
      }

      input[readonly],
      textarea[readonly] {
        background-color: #f3f4f6;
        color: #374151;
      }

      textarea {
        min-height: 160px;
        resize: vertical;
      }

      .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1rem;
      }

      .image-grid figure {
        position: relative;
        margin: 0;
        background: #ffffff;
        border-radius: 16px;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      }

      .image-remove {
        position: absolute;
        inset: 0.35rem 0.35rem auto auto;
        border: none;
        border-radius: 999px;
        width: 32px;
        height: 32px;
        display: grid;
        place-items: center;
        background: rgba(239, 68, 68, 0.92);
        color: #ffffff;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .image-remove:hover,
      .image-remove:focus {
        transform: translateY(-1px);
        filter: brightness(1.05);
        box-shadow: 0 8px 18px rgba(239, 68, 68, 0.35);
        outline: none;
      }

      .image-remove:active {
        transform: translateY(1px);
      }

      .image-grid img {
        width: 100%;
        aspect-ratio: 1 / 1;
        object-fit: cover;
        border-radius: 12px;
        background-color: #e5e7eb;
      }

      .image-grid figcaption {
        font-size: 0.875rem;
        color: #4b5563;
        text-align: center;
      }

      .upload-preview {
        margin-top: 0.75rem;
      }

      .upload-preview figure {
        box-shadow: 0 8px 18px rgba(79, 70, 229, 0.12);
      }

      .upload-preview figcaption {
        color: #4338ca;
      }

      .form-actions {
        display: flex;
        justify-content: flex-end;
        padding-top: 0.5rem;
      }

      .form-actions button {
        border: none;
        border-radius: 999px;
        padding: 0.9rem 2.75rem;
        font-weight: 600;
        font-size: 1rem;
        background: linear-gradient(120deg, #6366f1, #8b5cf6);
        color: #ffffff;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .form-actions button:hover,
      .form-actions button:focus {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(99, 102, 241, 0.25);
        outline: none;
      }

      .form-actions button:active {
        transform: translateY(1px);
        box-shadow: 0 8px 18px rgba(99, 102, 241, 0.25);
      }

      .form-actions button[disabled] {
        cursor: not-allowed;
        opacity: 0.7;
        box-shadow: none;
        transform: none;
      }

      .placeholder {
        color: #6b7280;
        font-style: italic;
      }

      .monitta-controls {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .monitta-search {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .monitta-search__label {
        font-weight: 600;
        color: #111827;
        font-size: 0.95rem;
      }

      .monitta-count {
        font-size: 0.9rem;
        color: #4b5563;
      }

      .monitta-status {
        margin: 0;
        padding: 0.75rem 1rem;
        border-radius: 12px;
        border: 1px solid rgba(99, 102, 241, 0.25);
        background: rgba(99, 102, 241, 0.08);
        color: #312e81;
        font-size: 0.95rem;
      }

      .monitta-status[data-status-type="error"] {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(254, 226, 226, 0.82);
        color: #991b1b;
      }

      .monitta-status[data-status-type="success"] {
        border-color: rgba(16, 185, 129, 0.35);
        background: rgba(209, 250, 229, 0.7);
        color: #065f46;
      }

      .monitta-options {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.75rem;
      }

      .monitta-option {
        background: #ffffff;
        border-radius: 16px;
        border: 1px solid #e5e7eb;
        box-shadow: 0 8px 18px rgba(99, 102, 241, 0.07);
        padding: 0.75rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .monitta-option__body {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .monitta-option__image {
        width: 72px;
        height: 72px;
        border-radius: 12px;
        object-fit: cover;
        background: #eef2ff;
        flex-shrink: 0;
      }

      .monitta-option__content {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        flex: 1 1 auto;
        min-width: 0;
      }

      .monitta-option__title {
        font-weight: 600;
        color: #1f2937;
      }

      .monitta-option__meta {
        font-size: 0.875rem;
        color: #4b5563;
      }

      .monitta-option__description {
        font-size: 0.85rem;
        color: #6b7280;
      }

      .monitta-option__link {
        align-self: flex-start;
        font-size: 0.85rem;
        font-weight: 600;
        color: #2563eb;
        text-decoration: none;
      }

      .monitta-option__link:hover,
      .monitta-option__link:focus {
        text-decoration: underline;
      }

      .monitta-option__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .monitta-add {
        border: none;
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        background: linear-gradient(120deg, #16a34a, #22c55e);
        color: #ffffff;
        font-weight: 600;
        font-size: 0.85rem;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .monitta-add:hover,
      .monitta-add:focus {
        filter: brightness(1.05);
        outline: none;
        box-shadow: 0 10px 18px rgba(34, 197, 94, 0.2);
      }

      .monitta-add:active {
        transform: translateY(1px);
      }

      .vintage-remove {
        border: none;
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        background: linear-gradient(120deg, #6366f1, #8b5cf6);
        color: #ffffff;
        font-weight: 600;
        font-size: 0.85rem;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .vintage-remove:hover,
      .vintage-remove:focus {
        filter: brightness(1.05);
        outline: none;
        box-shadow: 0 10px 18px rgba(99, 102, 241, 0.2);
      }

      .vintage-remove:active {
        transform: translateY(1px);
      }

      @media (min-width: 720px) {
        .monitta-controls {
          flex-direction: row;
          align-items: flex-end;
          justify-content: space-between;
        }

        .monitta-search {
          flex: 1 1 auto;
        }

        .monitta-count {
          text-align: right;
        }

        .monitta-option__actions {
          justify-content: flex-end;
        }
      }

      .vintage-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .vintage-item {
        background: #ffffff;
        border-radius: 16px;
        padding: 0.85rem 1rem;
        border: 1px solid #e5e7eb;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .vintage-item__body {
        display: flex;
        gap: 0.75rem;
        align-items: flex-start;
      }

      .vintage-item__image {
        width: 72px;
        height: 72px;
        border-radius: 12px;
        object-fit: cover;
        background: #f3f4f6;
        flex-shrink: 0;
      }

      .vintage-item__header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .vintage-item__content {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        flex: 1 1 auto;
        min-width: 0;
      }

      .vintage-item__details {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .vintage-item a {
        color: #2563eb;
        font-weight: 600;
        text-decoration: none;
      }

      .vintage-item a:hover,
      .vintage-item a:focus {
        text-decoration: underline;
      }

      .vintage-item small {
        color: #6b7280;
      }

      pre {
        margin: 0;
        padding: 1rem;
        background: #0f172a;
        color: #e0f2fe;
        border-radius: 14px;
        max-height: 360px;
        overflow: auto;
        font-size: 0.875rem;
      }

      @media (max-width: 720px) {
        body {
          padding: 1.5rem 0.75rem 2rem;
        }

        main {
          border-radius: 18px;
          padding: 1.75rem 1.25rem 2rem;
        }

        fieldset {
          padding: 1rem 1rem 1.25rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="top-actions">
        <a class="back-link" href="index.html">← Powrót do listy produktów</a>
      </div>
      <header>
        <h1>Edycja produktu</h1>
        <p class="subtitle">
          Wczytaj szczegóły istniejącej stylizacji, korzystając z identyfikatora produktu.
        </p>
      </header>
      <p id="status" role="status" aria-live="polite"></p>
      <form id="product-form" hidden novalidate>
        <fieldset>
          <legend>Podstawowe informacje</legend>
          <div class="field">
            <label for="product-name">Nazwa stylizacji</label>
            <input type="text" id="product-name" name="product-name" />
          </div>
          <div class="field">
            <label for="product-description">Opis</label>
            <textarea id="product-description" name="product-description"></textarea>
          </div>
        </fieldset>

        <fieldset>
          <legend>Zdjęcia produktu</legend>
          <div id="product-images" class="image-grid">
            <p class="placeholder">Brak zdjęć do wyświetlenia.</p>
          </div>
          <div class="field">
            <label for="new-images">Dodaj nowe zdjęcia</label>
            <input
              type="file"
              id="new-images"
              name="new-images"
              class="file-input"
              accept="image/*"
              multiple
            />
            <p class="hint">Możesz wybrać kilka plików graficznych (PNG, JPG, WebP) jednocześnie.</p>
            <div
              id="new-images-preview"
              class="image-grid upload-preview"
              aria-live="polite"
              aria-busy="false"
            >
              <p class="placeholder">Nie wybrano jeszcze nowych zdjęć.</p>
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Produkty vintage</legend>
          <ul id="vintage-products" class="vintage-list">
            <li class="placeholder">Brak powiązanych produktów vintage.</li>
          </ul>
        </fieldset>

        <fieldset>
          <legend>Produkty MonittaStore</legend>
          <p class="hint">
            Skorzystaj z listy produktów Monitta Store, aby dodać je do sekcji produktów
            vintage.
          </p>
          <div class="monitta-controls">
            <label class="monitta-search" for="monitta-store-search">
              <span class="monitta-search__label">Wyszukaj produkt</span>
              <input
                type="search"
                id="monitta-store-search"
                name="monitta-store-search"
                placeholder="Filtruj po nazwie, identyfikatorze lub rozmiarze"
                autocomplete="off"
              />
            </label>
            <span class="monitta-count" id="monitta-store-count" aria-live="polite"
              >Dodano z Monitta: 0</span
            >
          </div>
          <p class="monitta-status" id="monitta-store-status" role="status">
            Trwa przygotowywanie listy produktów Monitta Store…
          </p>
          <ul
            id="monitta-store-list"
            class="monitta-options"
            aria-live="polite"
            aria-busy="true"
          >
            <li class="placeholder">Lista produktów jest wczytywana…</li>
          </ul>
        </fieldset>

        <div class="form-actions">
          <button type="button" id="save-button">Zapisz</button>
        </div>
      </form>
    </main>
    <script>
      (function () {
        const statusElement = document.getElementById("status");
        const form = document.getElementById("product-form");
        const nameInput = document.getElementById("product-name");
        const descriptionInput = document.getElementById("product-description");
        const imagesContainer = document.getElementById("product-images");
        const newImagesInput = document.getElementById("new-images");
        const newImagesPreview = document.getElementById("new-images-preview");
        const vintageList = document.getElementById("vintage-products");
        const monittaStatusElement = document.getElementById("monitta-store-status");
        const monittaListElement = document.getElementById("monitta-store-list");
        const monittaSearchInput = document.getElementById("monitta-store-search");
        const monittaCountElement = document.getElementById("monitta-store-count");
        const saveButton = document.getElementById("save-button");

        const apiBaseUrl =
          "https://vintagecrawlerappservice-hqb0f5bmfrdwf0g7.polandcentral-01.azurewebsites.net/products";
        const uploadBaseUrl =
          "https://vintagecrawlerappservice-hqb0f5bmfrdwf0g7.polandcentral-01.azurewebsites.net/upload";
        const monittaEndpoint =
          "https://vintagecrawlerappservice-hqb0f5bmfrdwf0g7.polandcentral-01.azurewebsites.net/MonittaStore";

        const blobImageBaseUrl =
          "https://buythelookvintagestorage.blob.core.windows.net/uploads/";
        const blobImageQuery =
          "?sv=2024-11-04&ss=bfqt&srt=sco&sp=rl&se=2026-09-18T22:54:01Z&st=2025-09-18T14:39:01Z&spr=https&sig=roACoFS1yrHnyvMnUZWwy7w1VTfvQBL2jRCA9zGRdfA%3D";

        const monittaState = {
          isLoading: true,
          filter: "",
          allProducts: [],
          allProductsMap: new Map(),
          selectedMap: new Map(),
          error: null,
        };

        const toTrimmedString = (value, fallback = "") => {
          if (typeof value === "string") {
            const trimmed = value.trim();
            return trimmed || fallback;
          }

          if (value == null) {
            return fallback;
          }

          try {
            const trimmed = String(value).trim();
            return trimmed || fallback;
          } catch (error) {
            return fallback;
          }
        };

        const normalizeVintageProduct = (entry) => {
          if (!entry || typeof entry !== "object" || Array.isArray(entry)) {
            return null;
          }

          const normalized = { ...entry };
          normalized.VintageProductId = toTrimmedString(entry.VintageProductId);
          normalized.VintageProductName = toTrimmedString(entry.VintageProductName);
          normalized.VintageProductUrl = toTrimmedString(entry.VintageProductUrl);
          return normalized;
        };

        const normalizeProduct = (rawProduct, fallbackId = "") => {
          if (!rawProduct || typeof rawProduct !== "object") {
            return null;
          }

          const normalized = { ...rawProduct };
          const normalizedId = toTrimmedString(
            rawProduct.id ?? rawProduct.Id ?? rawProduct.ID,
            fallbackId,
          );
          normalized.id = normalizedId;
          normalized.Name = toTrimmedString(rawProduct.Name);
          normalized.Description = toTrimmedString(rawProduct.Description);

          const imageEntries = Array.isArray(rawProduct.Images)
            ? rawProduct.Images
            : [];
          const seenImages = new Set();
          normalized.Images = imageEntries
            .map((value) => toTrimmedString(value))
            .filter((value) => {
              if (!value || seenImages.has(value)) {
                return false;
              }
              seenImages.add(value);
              return true;
            });

          const vintageEntries = Array.isArray(rawProduct.VintageProducts)
            ? rawProduct.VintageProducts
            : [];
          normalized.VintageProducts = vintageEntries
            .map((entry) => normalizeVintageProduct(entry))
            .filter(Boolean);

          return normalized;
        };

        const params = new URLSearchParams(window.location.search);
        const productId = params.get("productID") ?? params.get("id");

        let currentProduct = null;
        let isSaving = false;
        let editableImages = [];
        let editableVintageProducts = [];

        const defaultSaveLabel =
          saveButton && typeof saveButton.textContent === "string"
            ? saveButton.textContent.trim() || "Zapisz"
            : "Zapisz";
        const savingLabel = "Zapisywanie…";

        const hasProductData = (product) =>
          !!(product && typeof product === "object" && Object.keys(product).length > 0);

        const updateSaveButtonState = () => {
          if (!saveButton) {
            return;
          }

          const shouldDisable = isSaving || !hasProductData(currentProduct);
          saveButton.disabled = shouldDisable;
          saveButton.textContent = isSaving ? savingLabel : defaultSaveLabel;
        };

        const setSavingState = (saving) => {
          isSaving = saving;

          if (saveButton) {
            saveButton.setAttribute("aria-busy", saving ? "true" : "false");
          }

          updateSaveButtonState();
        };

        updateSaveButtonState();

        const setStatus = (message, type = "info") => {
          if (!statusElement) {
            return;
          }

          statusElement.textContent = message;
          if (type === "info") {
            delete statusElement.dataset.statusType;
          } else {
            statusElement.dataset.statusType = type;
          }
          statusElement.hidden = false;
        };

        const toArray = (value) => {
          if (Array.isArray(value)) {
            return value;
          }

          if (!value) {
            return [];
          }

          if (typeof value === "object") {
            if (Array.isArray(value.items)) {
              return value.items;
            }
            if (Array.isArray(value.data)) {
              return value.data;
            }
            if (Array.isArray(value.products)) {
              return value.products;
            }
            if (Array.isArray(value.results)) {
              return value.results;
            }
            if (Array.isArray(value.entries)) {
              return value.entries;
            }
          }

          return [];
        };

        const resolveField = (source, candidates, fallback = "") => {
          if (typeof source !== "object" || source === null) {
            return fallback;
          }

          const keysToCheck = Array.isArray(candidates) ? candidates : [];
          const ownKeys = Object.keys(source);
          const normalizedMap = new Map();

          ownKeys.forEach((key) => {
            if (typeof key === "string") {
              const normalized = key.toLowerCase();
              if (!normalizedMap.has(normalized)) {
                normalizedMap.set(normalized, key);
              }
            }
          });

          for (const key of keysToCheck) {
            if (key in source && source[key] != null && source[key] !== "") {
              return source[key];
            }

            if (typeof key === "string") {
              const normalized = key.toLowerCase();
              if (normalizedMap.has(normalized)) {
                const actualKey = normalizedMap.get(normalized);
                const value = source[actualKey];
                if (value != null && value !== "") {
                  return value;
                }
              }
            }
          }

          return fallback;
        };

        const toDisplayString = (value) => {
          if (value == null) {
            return "";
          }

          if (typeof value === "string") {
            return value;
          }

          if (typeof value === "number" || typeof value === "bigint") {
            return String(value);
          }

          if (typeof value === "boolean") {
            return value ? "true" : "false";
          }

          return String(value);
        };

        const formatMonittaPrice = (product) => {
          if (!product || typeof product !== "object") {
            return "";
          }

          const priceSources = [
            product.price,
            product.total_item_price,
            product.totalItemPrice,
            product.total_price,
            product.totalPrice,
          ];

          for (const source of priceSources) {
            if (!source || typeof source !== "object") {
              continue;
            }

            const amountValue = resolveField(source, ["amount", "value"]);
            if (amountValue == null || amountValue === "") {
              continue;
            }

            const amountText = toDisplayString(amountValue).trim();
            if (!amountText) {
              continue;
            }

            const currencyValue =
              resolveField(source, ["currency_code", "currency", "currencyCode"]) ||
              resolveField(product, ["currency", "currency_code", "currencyCode", "priceCurrency"]);

            if (currencyValue != null && currencyValue !== "") {
              const currencyText = toDisplayString(currencyValue).trim();
              return currencyText ? `${amountText} ${currencyText}` : amountText;
            }

            return amountText;
          }

          const directAmount =
            product.price ?? product.amount ?? product.value ?? product.price_amount ?? product.priceValue;

          if (typeof directAmount === "number" || typeof directAmount === "string") {
            const amountText = toDisplayString(directAmount).trim();
            if (amountText) {
              const currencyValue = resolveField(product, [
                "currency",
                "currency_code",
                "currencyCode",
                "priceCurrency",
              ]);
              if (currencyValue != null && currencyValue !== "") {
                const currencyText = toDisplayString(currencyValue).trim();
                return currencyText ? `${amountText} ${currencyText}` : amountText;
              }
              return amountText;
            }
          }

          return "";
        };

        const getMonittaIdentifier = (source) => {
          if (source == null) {
            return "";
          }

          if (typeof source === "object" && !Array.isArray(source)) {
            let identifier = resolveField(source, [
              "id",
              "Id",
              "ID",
              "productId",
              "productID",
              "item_id",
              "itemId",
              "listingId",
              "listing_id",
              "VintageProductId",
              "vintageProductId",
            ]);

            if (identifier && typeof identifier === "object") {
              const nested = resolveField(identifier, ["id", "value"]);
              if (nested != null && nested !== "") {
                identifier = nested;
              }
            }

            if (identifier != null && identifier !== "") {
              const text = toDisplayString(identifier).trim();
              if (text) {
                return text;
              }
            }

            const fallback =
              resolveField(source, ["path", "slug"]) ||
              resolveField(source, [
                "VintageProductUrl",
                "vintageProductUrl",
                "url",
                "link",
                "productUrl",
                "href",
              ]);

            if (fallback != null && fallback !== "") {
              const text = toDisplayString(fallback).trim();
              if (text) {
                return text;
              }
            }

            return "";
          }

          return toDisplayString(source).trim();
        };

        const createMonittaEntry = (product) => {
          if (product == null) {
            return null;
          }

          const identifier = getMonittaIdentifier(product);
          if (!identifier) {
            return null;
          }

          const raw =
            typeof product === "object" && product !== null ? product : { id: identifier };

          const titleCandidate =
            typeof product === "object" && product !== null
              ? resolveField(product, [
                  "title",
                  "name",
                  "productName",
                  "label",
                  "VintageProductName",
                  "vintageProductName",
                ])
              : null;
          const title =
            titleCandidate && toDisplayString(titleCandidate).trim()
              ? toDisplayString(titleCandidate).trim()
              : `Produkt Monitta ${identifier}`;

          const priceText =
            typeof product === "object" && product !== null ? formatMonittaPrice(product) : "";

          const descriptionCandidate =
            typeof product === "object" && product !== null
              ? resolveField(product, ["description", "summary", "details"])
              : "";
          const description =
            descriptionCandidate && toDisplayString(descriptionCandidate).trim()
              ? toDisplayString(descriptionCandidate).trim()
              : "";

          const size =
            typeof product === "object" && product !== null ? resolveField(product, ["size"]) : "";
          const statusValue =
            typeof product === "object" && product !== null
              ? resolveField(product, ["status", "condition"])
              : "";
          const infoParts = [];
          if (size) {
            const sizeText = toDisplayString(size).trim();
            if (sizeText) {
              infoParts.push(sizeText);
            }
          }
          if (statusValue) {
            const statusText = toDisplayString(statusValue).trim();
            if (statusText) {
              infoParts.push(statusText);
            }
          }
          const info = infoParts.join(" · ");

          const url =
            typeof product === "object" && product !== null
              ? resolveField(product, [
                  "url",
                  "link",
                  "productUrl",
                  "href",
                  "VintageProductUrl",
                  "vintageProductUrl",
                ]) ?? ""
              : "";

          const photos =
            typeof product === "object" && product !== null
              ? toArray(product?.photos ?? product?.images ?? product?.image)
              : [];
          let thumbnail = "";
          if (photos.length > 0) {
            const firstPhoto = photos[0];
            if (typeof firstPhoto === "string") {
              thumbnail = firstPhoto;
            } else if (firstPhoto && typeof firstPhoto === "object") {
              thumbnail =
                resolveField(firstPhoto, [
                  "thumbnail_url",
                  "thumbnailUrl",
                  "url",
                  "imageUrl",
                  "src",
                  "href",
                  "small",
                ]) || resolveField(firstPhoto, ["full_size_url", "fullSizeUrl"]);
            }
          }
          if (!thumbnail && typeof product === "object" && product !== null) {
            thumbnail = resolveField(product, ["image", "imageUrl", "thumbnail", "thumbnailUrl"]);
          }

          return {
            id: identifier,
            title,
            priceText: priceText ? toDisplayString(priceText).trim() : "",
            description,
            info,
            url: url ? toDisplayString(url).trim() : "",
            thumbnail: thumbnail ? toDisplayString(thumbnail).trim() : "",
            raw,
          };
        };

        const cloneProduct = (product) => {
          if (!product || typeof product !== "object") {
            return {};
          }

          if (typeof structuredClone === "function") {
            try {
              return structuredClone(product);
            } catch (error) {
              // Ignore cloning errors and fall back to alternative strategies.
            }
          }

          try {
            return JSON.parse(JSON.stringify(product));
          } catch (error) {
            return { ...product };
          }
        };

        const updateKnownFields = (target, keys, value) => {
          if (!target || typeof target !== "object" || !Array.isArray(keys) || keys.length === 0) {
            return;
          }

          let updated = false;
          keys.forEach((key) => {
            if (key in target) {
              target[key] = value;
              updated = true;
            }
          });

          const primaryKey = keys[0];
          if (!updated || !(primaryKey in target)) {
            target[primaryKey] = value;
          }
        };

        const ensureIdentifier = (target) => {
          if (!target || typeof target !== "object") {
            return target;
          }

          const fallbackId = (productId ?? "").toString().trim();
          if (!fallbackId) {
            return target;
          }

          const identifierKeys = ["id", "Id", "ID", "productId", "productID"];
          let found = false;

          identifierKeys.forEach((key) => {
            if (!(key in target)) {
              return;
            }

            const value = target[key];
            if (value != null && String(value).trim() !== "") {
              found = true;
              return;
            }

            target[key] = fallbackId;
            found = true;
          });

          if (!found) {
            target.id = fallbackId;
          }

          return target;
        };

        const duplicateMonittaEntry = (entry, existing = null) => {
          if (!entry || typeof entry !== "object") {
            return null;
          }

          const identifier = entry.id ?? existing?.id;
          if (!identifier) {
            return null;
          }

          const baseRaw =
            entry.raw && typeof entry.raw === "object"
              ? entry.raw
              : existing && existing.raw && typeof existing.raw === "object"
              ? existing.raw
              : { id: identifier };

          let rawClone = cloneProduct(baseRaw);
          if (!rawClone || typeof rawClone !== "object" || Object.keys(rawClone).length === 0) {
            rawClone = { id: identifier };
          } else if (!("id" in rawClone) && identifier) {
            rawClone.id = identifier;
          }

          return {
            id: identifier,
            title: entry.title ?? existing?.title ?? `Produkt Monitta ${identifier}`,
            priceText: entry.priceText ?? existing?.priceText ?? "",
            description: entry.description ?? existing?.description ?? "",
            info: entry.info ?? existing?.info ?? "",
            url: entry.url ?? existing?.url ?? "",
            thumbnail: entry.thumbnail ?? existing?.thumbnail ?? "",
            raw: rawClone,
          };
        };

        const monittaProductsKeys = [
          "monittaStoreProducts",
          "monittaProducts",
          "monittaStoreItems",
          "monittaStore",
          "monittaAssociatedProducts",
        ];

        const monittaIdentifierKeys = ["monittaStoreProductIds", "monittaProductIds", "monittaIds"];

        const sanitizeMonittaEntryForPayload = (entry) => {
          if (entry && typeof entry === "object" && !Array.isArray(entry)) {
            const clone = cloneProduct(entry);
            const identifier = getMonittaIdentifier(clone);
            if (
              identifier &&
              (!("id" in clone) || clone.id == null || String(clone.id).trim() === "")
            ) {
              clone.id = identifier;
            }
            return clone;
          }

          const identifier = getMonittaIdentifier(entry);
          if (!identifier) {
            return null;
          }

          return { id: identifier };
        };

        const sanitizeMonittaEntries = (entries) => {
          if (!Array.isArray(entries)) {
            return [];
          }

          return entries
            .map((item) => sanitizeMonittaEntryForPayload(item))
            .filter(
              (item) =>
                item && typeof item === "object" && !Array.isArray(item) && Object.keys(item).length > 0
            );
        };

        const gatherMonittaIdentifiers = (items) => {
          const identifiers = new Set();
          toArray(items).forEach((item) => {
            const identifier = getMonittaIdentifier(item);
            if (typeof identifier !== "string") {
              return;
            }
            const trimmed = identifier.trim();
            if (trimmed) {
              identifiers.add(trimmed);
            }
          });
          return Array.from(identifiers);
        };

        const gatherNormalizedMonittaIdentifierSet = (items) => {
          const normalized = new Set();
          gatherMonittaIdentifiers(items).forEach((identifier) => {
            normalized.add(identifier.toLowerCase());
          });
          return normalized;
        };

        const getVintageProductIdentifier = (source) => {
          if (source == null) {
            return "";
          }

          if (typeof source === "object" && !Array.isArray(source)) {
            const identifier = resolveField(source, [
              "VintageProductId",
              "vintageProductId",
              "id",
              "Id",
              "ID",
              "productId",
              "productID",
            ]);
            if (identifier != null && identifier !== "") {
              const text = toDisplayString(identifier).trim();
              if (text) {
                return text;
              }
            }

            const urlFallback = resolveField(source, [
              "VintageProductUrl",
              "vintageProductUrl",
              "url",
              "link",
              "productUrl",
              "href",
            ]);
            if (urlFallback != null && urlFallback !== "") {
              const text = toDisplayString(urlFallback).trim();
              if (text) {
                return text;
              }
            }

            const nameFallback = resolveField(source, [
              "VintageProductName",
              "vintageProductName",
              "name",
              "title",
              "productName",
              "label",
            ]);
            if (nameFallback != null && nameFallback !== "") {
              const text = toDisplayString(nameFallback).trim();
              if (text) {
                return text;
              }
            }

            return "";
          }

          return toDisplayString(source).trim();
        };

        const createVintageProductFromMonitta = (entry) => {
          if (!entry || typeof entry !== "object") {
            return null;
          }

          const identifier = getMonittaIdentifier(entry);
          if (!identifier) {
            return null;
          }

          const titleCandidate = resolveField(entry, [
            "VintageProductName",
            "vintageProductName",
            "title",
            "name",
            "productName",
            "label",
          ]);
          const titleText = titleCandidate ? toDisplayString(titleCandidate).trim() : "";
          const urlCandidate = resolveField(entry, [
            "VintageProductUrl",
            "vintageProductUrl",
            "url",
            "link",
            "productUrl",
            "href",
          ]);
          const urlText = urlCandidate ? toDisplayString(urlCandidate).trim() : "";
          const name = titleText || `Produkt Monitta ${identifier}`;

          return {
            VintageProductId: identifier,
            vintageProductId: identifier,
            VintageProductName: name,
            vintageProductName: name,
            VintageProductUrl: urlText,
            vintageProductUrl: urlText,
          };
        };

        const getExistingVintageProducts = (source) => {
          if (!source || typeof source !== "object") {
            return [];
          }

          const candidates = [source?.VintageProducts, source?.vintageProducts, source?.relatedProducts];
          for (const candidate of candidates) {
            const array = toArray(candidate);
            if (array.length > 0) {
              return array
                .map((item) =>
                  typeof item === "object" && item !== null
                    ? normalizeVintageProduct(item)
                    : null,
                )
                .filter(Boolean)
                .map((entry) => cloneProduct(entry));
            }
          }

          return [];
        };

        const assignVintageProductsToTarget = (target, entries) => {
          if (!target || typeof target !== "object") {
            return;
          }

          const normalized = (Array.isArray(entries) ? entries : []).map((entry) =>
            typeof entry === "object" && entry !== null ? cloneProduct(entry) : entry
          );
          target.VintageProducts = normalized.map((entry) =>
            typeof entry === "object" && entry !== null ? cloneProduct(entry) : entry
          );
          target.vintageProducts = normalized.map((entry) =>
            typeof entry === "object" && entry !== null ? cloneProduct(entry) : entry
          );
        };

        const mergeMonittaIntoVintageProducts = (target, monittaEntries, previousIds = new Set()) => {
          if (!target || typeof target !== "object") {
            return;
          }

          const sanitizedEntries = Array.isArray(monittaEntries) ? monittaEntries : [];
          const previousIdValues = Array.isArray(previousIds)
            ? previousIds
            : previousIds instanceof Set
            ? Array.from(previousIds)
            : toArray(previousIds);
          const normalizedPreviousIds = new Set();
          previousIdValues.forEach((value) => {
            const identifier =
              typeof value === "string" ? value : getMonittaIdentifier(value);
            if (typeof identifier === "string") {
              const trimmed = identifier.trim();
              if (trimmed) {
                normalizedPreviousIds.add(trimmed.toLowerCase());
              }
            }
          });

          const currentNormalizedIds = gatherNormalizedMonittaIdentifierSet(sanitizedEntries);
          const idsToReplace = new Set([...normalizedPreviousIds, ...currentNormalizedIds]);

          const existingVintage = getExistingVintageProducts(target).filter((item) => {
            const identifier = getVintageProductIdentifier(item);
            if (!identifier) {
              return true;
            }
            return !idsToReplace.has(identifier.toLowerCase());
          });

          const monittaVintageEntries = sanitizedEntries
            .map((entry) => createVintageProductFromMonitta(entry))
            .filter((entry) => entry && entry.VintageProductId);

          const combined = [...existingVintage, ...monittaVintageEntries];
          assignVintageProductsToTarget(target, combined);
        };

        const assignMonittaProductsToTarget = (target, products) => {
          if (!target || typeof target !== "object") {
            return;
          }

          const baseEntries = (Array.isArray(products) ? products : []).map((entry) =>
            cloneProduct(entry)
          );

          monittaProductsKeys.forEach((key) => {
            target[key] = baseEntries.map((entry) => cloneProduct(entry));
          });
        };

        const assignMonittaIdentifiersToTarget = (target, identifiers) => {
          if (!target || typeof target !== "object") {
            return;
          }

          const baseIdentifiers = Array.isArray(identifiers) ? identifiers : [];
          monittaIdentifierKeys.forEach((key) => {
            target[key] = baseIdentifiers.map((identifier) => identifier);
          });
        };

        const toImageStringForPayload = (image) => {
          if (image == null) {
            return "";
          }

          if (
            typeof image === "string" ||
            typeof image === "number" ||
            typeof image === "bigint"
          ) {
            const text = toDisplayString(image).trim();
            if (!text) {
              return "";
            }
            const normalized = normalizeBlobFile(text);
            return normalized || text;
          }

          if (typeof File !== "undefined" && image instanceof File) {
            const fileName = image.name && image.name.trim() ? image.name.trim() : "";
            if (!fileName) {
              return "";
            }
            const normalized = normalizeBlobFile(fileName);
            return normalized || fileName;
          }

          if (typeof image === "object") {
            const fileCandidate = resolveImageFileCandidate(image);
            if (fileCandidate) {
              return fileCandidate;
            }

            const urlCandidate = resolveImageUrlCandidate(image);
            if (urlCandidate) {
              const normalizedUrl = normalizeBlobFile(urlCandidate);
              return normalizedUrl || urlCandidate;
            }

            const directCandidate = resolveField(
              image,
              [
                "Image",
                "image",
                "imageUrl",
                "ImageUrl",
                "url",
                "href",
                "link",
                "src",
                "path",
                "file",
                "fileName",
                "filename",
                "name",
                "value",
                "blobName",
                "blob",
                "key",
              ],
              ""
            );

            if (directCandidate != null && directCandidate !== "") {
              const text = toDisplayString(directCandidate).trim();
              if (text) {
                const normalized = normalizeBlobFile(text);
                return normalized || text;
              }
            }
          }

          return "";
        };

        const gatherImagesForPayload = (...sources) => {
          const results = [];
          const seenValues = new Set();
          const queue = [];
          const seenObjects = new Set();

          sources.forEach((source) => {
            if (source != null) {
              queue.push(source);
            }
          });

          while (queue.length > 0) {
            const current = queue.shift();

            if (current == null) {
              continue;
            }

            if (Array.isArray(current)) {
              current.forEach((item) => queue.push(item));
              continue;
            }

            const imageString = toImageStringForPayload(current);
            if (imageString) {
              if (!seenValues.has(imageString)) {
                seenValues.add(imageString);
                results.push(imageString);
              }
              continue;
            }

            if (typeof current === "object") {
              if (typeof File !== "undefined" && current instanceof File) {
                continue;
              }

              if (seenObjects.has(current)) {
                continue;
              }
              seenObjects.add(current);

              Object.values(current).forEach((value) => {
                if (value != null) {
                  queue.push(value);
                }
              });
            }
          }

          return results;
        };

        const sanitizeVintageProductEntry = (entry, fallbackIndex = 0) => {
          if (entry == null) {
            return null;
          }

          if (
            typeof entry === "string" ||
            typeof entry === "number" ||
            typeof entry === "bigint"
          ) {
            const text = toDisplayString(entry).trim();
            if (!text) {
              return null;
            }
            return {
              VintageProductId: text,
              VintageProductName: text,
              VintageProductUrl: "",
            };
          }

          if (typeof entry !== "object") {
            return null;
          }

          const identifier = getVintageProductIdentifier(entry);
          const idText = identifier ? toDisplayString(identifier).trim() : "";
          if (!idText) {
            return null;
          }

          const nameCandidate = resolveField(
            entry,
            [
              "VintageProductName",
              "vintageProductName",
              "name",
              "Name",
              "title",
              "productName",
              "label",
            ],
            ""
          );
          const nameText =
            nameCandidate != null && toDisplayString(nameCandidate).trim()
              ? toDisplayString(nameCandidate).trim()
              : "";
          const finalName = nameText || `Vintage product ${fallbackIndex + 1}`;

          const urlCandidate = resolveField(
            entry,
            [
              "VintageProductUrl",
              "vintageProductUrl",
              "url",
              "link",
              "productUrl",
              "href",
            ],
            ""
          );
          const urlText =
            urlCandidate != null && toDisplayString(urlCandidate).trim()
              ? toDisplayString(urlCandidate).trim()
              : "";

          return {
            VintageProductId: idText,
            VintageProductName: finalName,
            VintageProductUrl: urlText,
          };
        };

        const sanitizeVintageProductsForPayload = (entries) => {
          const sanitized = [];
          const seen = new Set();
          const items = Array.isArray(entries) ? entries : [];

          items.forEach((entry, index) => {
            const cleaned = sanitizeVintageProductEntry(entry, index);
            if (!cleaned) {
              return;
            }

            const identifierText = cleaned.VintageProductId
              ? toDisplayString(cleaned.VintageProductId).trim()
              : "";

            if (identifierText) {
              const normalizedId = identifierText.toLowerCase();
              if (seen.has(normalizedId)) {
                return;
              }
              seen.add(normalizedId);
            }

            sanitized.push(cleaned);
          });

          return sanitized;
        };

        const getMonittaEntryByIdentifier = (identifier) => {
          if (identifier == null) {
            return null;
          }

          const idText = toDisplayString(identifier).trim();
          if (!idText) {
            return null;
          }

          if (monittaState.selectedMap.has(idText)) {
            return monittaState.selectedMap.get(idText);
          }

          if (monittaState.allProductsMap.has(idText)) {
            return monittaState.allProductsMap.get(idText);
          }

          const normalized = idText.toLowerCase();

          for (const [key, value] of monittaState.selectedMap.entries()) {
            if (typeof key === "string" && key.toLowerCase() === normalized) {
              return value;
            }
          }

          for (const [key, value] of monittaState.allProductsMap.entries()) {
            if (typeof key === "string" && key.toLowerCase() === normalized) {
              return value;
            }
          }

          return null;
        };

        const resolveMonittaImageUrl = (entry) => {
          if (!entry) {
            return "";
          }

          const sources = [];

          if (entry && typeof entry === "object") {
            if (entry.thumbnail != null) {
              sources.push(entry.thumbnail);
            }
            if (entry.raw && typeof entry.raw === "object") {
              sources.push(entry.raw);
            }
            sources.push(entry);
          }

          return findFirstImageUrl(...sources) || "";
        };

        const resolveVintageImageUrl = (item) => {
          if (!item) {
            return "";
          }

          const identifier = getVintageProductIdentifier(item);
          if (identifier) {
            const monittaEntry = getMonittaEntryByIdentifier(identifier);
            if (monittaEntry) {
              const fromMonitta = resolveMonittaImageUrl(monittaEntry);
              if (fromMonitta) {
                return fromMonitta;
              }
            }
          }

          const sources = [];

          if (item && typeof item === "object") {
            if (item.VintageProductImage != null) {
              sources.push({ image: item.VintageProductImage });
            }
            if (item.vintageProductImage != null) {
              sources.push({ image: item.vintageProductImage });
            }
            sources.push(item);
          }

          return findFirstImageUrl(...sources) || "";
        };

        const isAbsoluteUrl = (value) =>
          typeof value === "string" && /^https?:\/\//i.test(value.trim());

        const normalizeBlobFile = (value) => {
          if (value == null) {
            return "";
          }

          const text = toDisplayString(value).trim();
          if (!text) {
            return "";
          }

          const withoutQuery = text.split("?")[0];
          const withoutPrefix = withoutQuery.replace(
            /^https?:\/\/[^/]+\/uploads\//i,
            ""
          );

          const normalized = withoutPrefix.replace(/^\/+/, "");
          if (!normalized || /^https?:\/\//i.test(normalized)) {
            return "";
          }

          return normalized;
        };

        const resolveImageFileCandidate = (image) => {
          if (typeof image === "string") {
            return normalizeBlobFile(image);
          }

          if (image && typeof image === "object") {
            const candidate = resolveField(
              image,
              [
                "fileName",
                "file",
                "filename",
                "name",
                "imageFile",
                "image",
                "path",
                "blobName",
                "blob",
                "key",
              ],
              ""
            );

            if (candidate != null && candidate !== "") {
              const normalized = normalizeBlobFile(candidate);
              if (normalized) {
                return normalized;
              }
            }

            const urlCandidate = resolveField(
              image,
              ["url", "imageUrl", "src", "href", "link"],
              ""
            );

            if (urlCandidate != null && urlCandidate !== "") {
              const normalized = normalizeBlobFile(urlCandidate);
              if (normalized) {
                return normalized;
              }
            }
          }

          return "";
        };

        const resolveImageUrlCandidate = (image) => {
          if (typeof image === "string") {
            const text = toDisplayString(image).trim();
            return isAbsoluteUrl(text) ? text : "";
          }

          if (image && typeof image === "object") {
            const candidate = resolveField(
              image,
              ["url", "imageUrl", "src", "href", "link"],
              ""
            );
            const text = candidate != null ? toDisplayString(candidate).trim() : "";
            return isAbsoluteUrl(text) ? text : "";
          }

          return "";
        };

        const buildImageUrlFromEntry = (image) => {
          const absoluteUrl = resolveImageUrlCandidate(image);
          const normalizedFromUrl = normalizeBlobFile(absoluteUrl);

          if (normalizedFromUrl) {
            return `${blobImageBaseUrl}${normalizedFromUrl}${blobImageQuery}`;
          }

          const fileCandidate = resolveImageFileCandidate(image);
          if (fileCandidate) {
            return `${blobImageBaseUrl}${fileCandidate}${blobImageQuery}`;
          }

          if (absoluteUrl) {
            return absoluteUrl;
          }

          return "";
        };

        const findFirstImageUrl = (...sources) => {
          const queue = [];
          const seen = new Set();

          const enqueue = (value, context = false) => {
            if (value == null) {
              return;
            }
            queue.push({ value, context });
          };

          sources.forEach((source) => {
            if (Array.isArray(source)) {
              enqueue(source, typeof source === "string");
            } else {
              const initialContext = typeof source === "string";
              enqueue(source, initialContext);
            }
          });

          while (queue.length > 0) {
            const { value, context } = queue.shift();

            if (Array.isArray(value)) {
              value.forEach((item) => enqueue(item, context));
              continue;
            }

            if (typeof value === "string") {
              if (!context) {
                continue;
              }
              const trimmed = value.trim();
              if (!trimmed) {
                continue;
              }
              const url = buildImageUrlFromEntry(value);
              if (url) {
                return url;
              }
              continue;
            }

            if (typeof value !== "object") {
              continue;
            }

            if (seen.has(value)) {
              continue;
            }
            seen.add(value);

            if (context) {
              const url = buildImageUrlFromEntry(value);
              if (url) {
                return url;
              }
            }

            Object.entries(value).forEach(([key, nested]) => {
              if (nested == null) {
                return;
              }
              const lowerKey = key.toLowerCase();
              const nextContext =
                context ||
                lowerKey.includes("image") ||
                lowerKey.includes("photo") ||
                lowerKey.includes("thumb") ||
                lowerKey.includes("picture") ||
                lowerKey.includes("img");
              enqueue(nested, nextContext);
            });
          }

          return "";
        };

        const getImageAltText = (image, index) => {
          if (image && typeof image === "object") {
            const candidate = resolveField(
              image,
              ["alt", "description", "title", "name"],
              ""
            );
            const text = candidate != null ? toDisplayString(candidate).trim() : "";
            if (text) {
              return text;
            }
          }

          if (typeof image === "string") {
            const text = toDisplayString(image).trim();
            if (text && !isAbsoluteUrl(text)) {
              return text;
            }
          }

          const fileCandidate = resolveImageFileCandidate(image);
          if (fileCandidate) {
            return fileCandidate;
          }

          return `Zdjęcie ${index + 1}`;
        };

        const getProductImagesArray = (product) => {
          if (!product || typeof product !== "object") {
            return [];
          }

          const candidates = [product.Images, product.images, product.image, product.photos];
          for (const candidate of candidates) {
            const array = toArray(candidate);
            if (array.length > 0) {
              return array.map((item) =>
                typeof item === "object" && item !== null ? cloneProduct(item) : item
              );
            }
          }

          return [];
        };

        const assignImagesToTarget = (target, images) => {
          if (!target || typeof target !== "object") {
            return;
          }

          const normalized = (Array.isArray(images) ? images : []).map((item) =>
            typeof item === "object" && item !== null ? cloneProduct(item) : item
          );

          ["Images", "images", "image", "photos"].forEach((key) => {
            target[key] = normalized.map((item) =>
              typeof item === "object" && item !== null ? cloneProduct(item) : item
            );
          });
        };

        const setEditableImagesFromProduct = (product) => {
          editableImages = getProductImagesArray(product);
        };

        const syncEditableImagesToProduct = () => {
          if (!currentProduct) {
            return;
          }

          assignImagesToTarget(currentProduct, editableImages);
        };

        const setEditableVintageFromProduct = (product) => {
          editableVintageProducts = getExistingVintageProducts(product);
        };

        const syncEditableVintageToProduct = () => {
          if (!currentProduct) {
            return;
          }

          assignVintageProductsToTarget(currentProduct, editableVintageProducts);
        };

        const setMonittaStatus = (message, type = "info") => {
          if (!monittaStatusElement) {
            return;
          }

          if (!message) {
            monittaStatusElement.textContent = "";
            monittaStatusElement.hidden = true;
            monittaStatusElement.removeAttribute("data-status-type");
            return;
          }

          monittaStatusElement.hidden = false;
          monittaStatusElement.textContent = message;

          if (type === "info") {
            monittaStatusElement.removeAttribute("data-status-type");
          } else {
            monittaStatusElement.dataset.statusType = type;
          }
        };

        const updateMonittaCount = () => {
          if (!monittaCountElement) {
            return;
          }

          const count = monittaState.selectedMap.size;
          monittaCountElement.textContent = `Dodano z Monitta: ${count}`;
        };

        const createMonittaPlaceholder = (message) => {
          const item = document.createElement("li");
          item.className = "placeholder";
          item.textContent = message;
          return item;
        };

        const getFilteredMonittaProducts = () => {
          const term = monittaState.filter.trim().toLowerCase();
          if (!term) {
            return monittaState.allProducts;
          }

          return monittaState.allProducts.filter((entry) => {
            const haystack = [entry.title, entry.priceText, entry.info, entry.description, entry.id]
              .filter((value) => typeof value === "string" && value)
              .join(" ")
              .toLowerCase();
            return haystack.includes(term);
          });
        };

        const renderMonittaList = () => {
          if (!monittaListElement) {
            return;
          }

          monittaListElement.innerHTML = "";
          monittaListElement.setAttribute("aria-busy", monittaState.isLoading ? "true" : "false");

          if (monittaState.isLoading) {
            monittaListElement.appendChild(
              createMonittaPlaceholder("Lista produktów jest wczytywana…")
            );
            return;
          }

          if (monittaState.error && monittaState.allProducts.length === 0) {
            monittaListElement.appendChild(createMonittaPlaceholder(monittaState.error));
            return;
          }

          const products = getFilteredMonittaProducts().filter((entry) => {
            if (!entry || typeof entry !== "object") {
              return false;
            }
            return !monittaState.selectedMap.has(entry.id);
          });

          if (products.length === 0) {
            const message = monittaState.filter
              ? "Brak produktów spełniających kryteria wyszukiwania."
              : "Brak produktów Monitta Store do dodania.";
            monittaListElement.appendChild(createMonittaPlaceholder(message));
            return;
          }

          const fragment = document.createDocumentFragment();

          products.forEach((entry) => {
            const listItem = document.createElement("li");
            listItem.className = "monitta-option";
            listItem.dataset.monittaId = entry.id;

            const content = document.createElement("div");
            content.className = "monitta-option__content";

            const title = document.createElement("span");
            title.className = "monitta-option__title";
            title.textContent = entry.title;
            content.appendChild(title);

            if (entry.priceText || entry.info) {
              const meta = document.createElement("span");
              meta.className = "monitta-option__meta";
              if (entry.priceText && entry.info) {
                meta.textContent = `${entry.priceText} · ${entry.info}`;
              } else {
                meta.textContent = entry.priceText || entry.info;
              }
              content.appendChild(meta);
            }

            if (entry.description) {
              const description = document.createElement("span");
              description.className = "monitta-option__description";
              description.textContent = entry.description;
              content.appendChild(description);
            }

            const body = document.createElement("div");
            body.className = "monitta-option__body";

            const imageUrl = resolveMonittaImageUrl(entry);
            if (imageUrl) {
              const image = document.createElement("img");
              image.className = "monitta-option__image";
              image.src = imageUrl;
              image.loading = "lazy";
              image.decoding = "async";
              const altTitle = toDisplayString(entry.title ?? "").trim();
              image.alt = altTitle
                ? `Zdjęcie ${altTitle}`
                : "Zdjęcie produktu Monitta Store";
              body.appendChild(image);
            }

            body.appendChild(content);
            listItem.appendChild(body);

            const actions = document.createElement("div");
            actions.className = "monitta-option__actions";

            const addButton = document.createElement("button");
            addButton.type = "button";
            addButton.className = "monitta-add";
            addButton.dataset.monittaAdd = entry.id;
            addButton.textContent = "Dodaj do vintage";
            actions.appendChild(addButton);

            if (entry.url) {
              const link = document.createElement("a");
              link.href = entry.url;
              link.target = "_blank";
              link.rel = "noopener";
              link.className = "monitta-option__link";
              link.textContent = "Zobacz na Monitta Store";
              actions.appendChild(link);
            }

            listItem.appendChild(actions);

            fragment.appendChild(listItem);
          });

          monittaListElement.appendChild(fragment);
        };

        const getMonittaPayload = () => {
          const payload = [];
          monittaState.selectedMap.forEach((entry) => {
            if (!entry) {
              return;
            }

            const base =
              entry.raw && typeof entry.raw === "object" ? entry.raw : { id: entry.id };
            let clone = cloneProduct(base);
            if (!clone || typeof clone !== "object" || Object.keys(clone).length === 0) {
              clone = { id: entry.id };
            } else if (entry.id && !("id" in clone)) {
              clone.id = entry.id;
            }
            payload.push(clone);
          });
          return payload;
        };

        const updateMonittaSelectionInProduct = () => {
          if (!currentProduct || typeof currentProduct !== "object") {
            return;
          }

          const previousIdentifierValues = [];
          [
            currentProduct?.monittaStoreProducts,
            currentProduct?.monittaStoreProductIds,
            currentProduct?.monittaProducts,
            currentProduct?.monittaProductIds,
            currentProduct?.monittaStoreItems,
            currentProduct?.monittaIds,
          ].forEach((source) => {
            previousIdentifierValues.push(...toArray(source));
          });

          const previousIdentifiers = gatherNormalizedMonittaIdentifierSet(previousIdentifierValues);

          const selectedPayload = getMonittaPayload();
          const sanitizedSelected = sanitizeMonittaEntries(selectedPayload);
          const identifiers = gatherMonittaIdentifiers(sanitizedSelected);

          assignMonittaProductsToTarget(currentProduct, sanitizedSelected);
          assignMonittaIdentifiersToTarget(currentProduct, identifiers);
          mergeMonittaIntoVintageProducts(currentProduct, sanitizedSelected, previousIdentifiers);
        };

        const setMonittaSelectedFromProduct = (product) => {
          monittaState.selectedMap.clear();

          const candidateKeys = [
            "monittaStoreProducts",
            "monittaProducts",
            "monittaStoreItems",
            "monittaStore",
            "monittaAssociatedProducts",
          ];

          candidateKeys.forEach((key) => {
            const items = toArray(product?.[key]);
            items.forEach((item) => {
              const entry = createMonittaEntry(item);
              if (!entry) {
                return;
              }
              const selectedEntry = duplicateMonittaEntry(entry);
              if (selectedEntry) {
                monittaState.selectedMap.set(selectedEntry.id, selectedEntry);
              }
            });
          });

          const includeVintageMonittaProducts = (source) => {
            toArray(source).forEach((item) => {
              if (!item || typeof item !== "object" || Array.isArray(item)) {
                return;
              }

              const identifierCandidate = resolveField(
                item,
                ["VintageProductId", "vintageProductId"],
                ""
              );
              if (!identifierCandidate || String(identifierCandidate).trim() === "") {
                return;
              }

              const entry = createMonittaEntry(item);
              if (!entry) {
                return;
              }

              const selectedEntry = duplicateMonittaEntry(
                entry,
                monittaState.selectedMap.get(entry.id) ?? null
              );
              if (selectedEntry) {
                monittaState.selectedMap.set(selectedEntry.id, selectedEntry);
              }
            });
          };

          includeVintageMonittaProducts(product?.VintageProducts);
          includeVintageMonittaProducts(product?.vintageProducts);

          const idCandidates = toArray(
            product?.monittaStoreProductIds ?? product?.monittaProductIds ?? product?.monittaIds
          );
          idCandidates.forEach((candidate) => {
            const entry =
              typeof candidate === "object" && candidate !== null
                ? createMonittaEntry(candidate)
                : createMonittaEntry({ id: candidate });
            if (!entry) {
              return;
            }
            const existing = monittaState.selectedMap.get(entry.id);
            const selectedEntry = duplicateMonittaEntry(entry, existing ?? null);
            if (selectedEntry) {
              monittaState.selectedMap.set(selectedEntry.id, selectedEntry);
            }
          });

          updateMonittaSelectionInProduct();
          if (currentProduct) {
            setEditableVintageFromProduct(currentProduct);
            renderVintageProducts();
          }
          updateMonittaCount();
          renderMonittaList();
        };

        const loadMonittaProducts = async () => {
          if (!monittaListElement) {
            return;
          }

          monittaState.isLoading = true;
          monittaState.error = null;
          monittaListElement.setAttribute("aria-busy", "true");
          setMonittaStatus("Trwa wczytywanie produktów Monitta Store…");

          try {
            const response = await fetch(monittaEndpoint);
            if (!response.ok) {
              throw new Error(`Żądanie nie powiodło się. Kod odpowiedzi: ${response.status}`);
            }

            const payload = await response.json();
            const rawProducts = toArray(payload);
            const uniqueEntries = new Map();
            rawProducts.forEach((item) => {
              const entry = createMonittaEntry(item);
              if (!entry || uniqueEntries.has(entry.id)) {
                return;
              }
              uniqueEntries.set(entry.id, entry);
            });

            const entries = Array.from(uniqueEntries.values());
            entries.sort((a, b) => a.title.localeCompare(b.title, "pl", { sensitivity: "base" }));

            monittaState.allProducts = entries;
            monittaState.allProductsMap = uniqueEntries;
            monittaState.error = null;

            monittaState.selectedMap.forEach((existingEntry, id) => {
              const datasetEntry = uniqueEntries.get(id);
              if (!datasetEntry) {
                return;
              }
              const mergedEntry = duplicateMonittaEntry(datasetEntry, existingEntry);
              if (mergedEntry) {
                monittaState.selectedMap.set(id, mergedEntry);
              }
            });

            if (entries.length === 0) {
              setMonittaStatus("Brak produktów Monitta Store do wyświetlenia.");
            } else {
              setMonittaStatus(`Wczytano ${entries.length} produktów Monitta Store.`);
            }
          } catch (error) {
            console.error("Błąd podczas wczytywania produktów Monitta Store:", error);
            monittaState.error = "Nie udało się pobrać listy produktów Monitta Store.";
            setMonittaStatus(monittaState.error, "error");
          } finally {
            monittaState.isLoading = false;
            monittaListElement.setAttribute("aria-busy", "false");
            renderMonittaList();
            updateMonittaSelectionInProduct();
            if (currentProduct) {
              setEditableVintageFromProduct(currentProduct);
              renderVintageProducts();
            }
            updateMonittaCount();
          }
        };

        const isImageFile = (file) => {
          if (!file) {
            return false;
          }

          if (file.type && file.type.startsWith("image/")) {
            return true;
          }

          const name = (file.name ?? "").toLowerCase();
          const extensions = [
            ".png",
            ".jpg",
            ".jpeg",
            ".jfif",
            ".pjpeg",
            ".gif",
            ".bmp",
            ".webp",
            ".avif",
            ".heic",
            ".heif",
          ];

          return extensions.some((extension) => name.endsWith(extension));
        };

        const separateImageFiles = (fileList) => {
          const originalFiles = Array.from(fileList ?? []);
          const imageFiles = originalFiles.filter(isImageFile);

          return { originalFiles, imageFiles };
        };

        const getSelectedImageFiles = () => {
          const { imageFiles } = separateImageFiles(newImagesInput?.files);
          return imageFiles;
        };

        const renderImages = () => {
          if (!imagesContainer) {
            return;
          }

          imagesContainer.innerHTML = "";

          if (!Array.isArray(editableImages) || editableImages.length === 0) {
            const empty = document.createElement("p");
            empty.className = "placeholder";
            empty.textContent = "Brak zdjęć do wyświetlenia.";
            imagesContainer.appendChild(empty);
            return;
          }

          let rendered = 0;

          editableImages.forEach((image, index) => {
            const url = buildImageUrlFromEntry(image);
            if (!url) {
              return;
            }

            const altText = getImageAltText(image, index);

            const figure = document.createElement("figure");
            figure.dataset.imageIndex = String(index);

            const removeButton = document.createElement("button");
            removeButton.type = "button";
            removeButton.className = "image-remove";
            removeButton.dataset.imageIndex = String(index);
            removeButton.setAttribute("aria-label", `Usuń zdjęcie ${index + 1}`);
            removeButton.textContent = "X";
            figure.appendChild(removeButton);

            const img = document.createElement("img");
            img.src = url;
            img.loading = "lazy";
            img.alt = altText;
            figure.appendChild(img);

            const caption = document.createElement("figcaption");
            caption.textContent = altText;
            figure.appendChild(caption);

            imagesContainer.appendChild(figure);
            rendered += 1;
          });

          if (rendered === 0) {
            const empty = document.createElement("p");
            empty.className = "placeholder";
            empty.textContent = "Brak zdjęć do wyświetlenia.";
            imagesContainer.appendChild(empty);
          }
        };

        const removeImageAtIndex = (index) => {
          if (!Array.isArray(editableImages)) {
            return;
          }

          const normalizedIndex = Number(index);
          if (
            Number.isNaN(normalizedIndex) ||
            normalizedIndex < 0 ||
            normalizedIndex >= editableImages.length
          ) {
            return;
          }

          editableImages.splice(normalizedIndex, 1);
          syncEditableImagesToProduct();
          renderImages();
          updateSaveButtonState();
        };

        const renderSelectedImages = (fileList) => {
          if (!newImagesPreview) {
            return;
          }

          newImagesPreview.innerHTML = "";
          newImagesPreview.setAttribute("aria-busy", "true");

          const { originalFiles, imageFiles } = separateImageFiles(fileList);

          if (imageFiles.length === 0) {
            const empty = document.createElement("p");
            empty.className = "placeholder";
            empty.textContent =
              originalFiles.length > 0
                ? "Wybrane pliki nie są obsługiwanymi obrazami."
                : "Nie wybrano jeszcze nowych zdjęć.";
            newImagesPreview.appendChild(empty);
            newImagesPreview.setAttribute("aria-busy", "false");
            return;
          }

          if (typeof FileReader === "undefined") {
            const info = document.createElement("p");
            info.className = "placeholder";
            info.textContent = "Twoja przeglądarka nie obsługuje podglądu wybranych zdjęć.";
            newImagesPreview.appendChild(info);
            newImagesPreview.setAttribute("aria-busy", "false");
            return;
          }

          let pending = imageFiles.length;
          const markReady = () => {
            pending -= 1;
            if (pending <= 0) {
              newImagesPreview.setAttribute("aria-busy", "false");
            }
          };

          imageFiles.forEach((file, index) => {
            const figure = document.createElement("figure");
            const img = document.createElement("img");
            const caption = document.createElement("figcaption");
            const label = file.name && file.name.trim() ? file.name : `Nowe zdjęcie ${index + 1}`;

            img.loading = "lazy";
            img.alt = label;
            caption.textContent = label;

            figure.appendChild(img);
            figure.appendChild(caption);
            newImagesPreview.appendChild(figure);

            const reader = new FileReader();
            reader.addEventListener("load", () => {
              img.src = reader.result;
              markReady();
            });
            reader.addEventListener("error", markReady);
            reader.addEventListener("abort", markReady);
            try {
              reader.readAsDataURL(file);
            } catch (error) {
              console.error("Nie udało się wczytać pliku graficznego:", error);
              markReady();
            }
          });
        };

        renderSelectedImages(newImagesInput?.files ?? []);

        if (imagesContainer) {
          imagesContainer.addEventListener("click", (event) => {
            const target = event.target;
            if (!target || !(target instanceof HTMLElement)) {
              return;
            }

            if (!target.matches("button[data-image-index]")) {
              return;
            }

            const { imageIndex } = target.dataset;
            if (typeof imageIndex === "undefined") {
              return;
            }

            removeImageAtIndex(imageIndex);
          });
        }

        if (newImagesInput) {
          newImagesInput.addEventListener("change", () => {
            renderSelectedImages(newImagesInput.files);
          });
        }

        if (monittaSearchInput) {
          monittaSearchInput.addEventListener("input", () => {
            monittaState.filter = monittaSearchInput.value ?? "";
            renderMonittaList();
          });
        }

        if (monittaListElement) {
          monittaListElement.addEventListener("click", (event) => {
            const target = event.target;
            if (!target || !(target instanceof HTMLElement)) {
              return;
            }

            if (!target.matches("button[data-monitta-add]")) {
              return;
            }

            const identifier = target.dataset.monittaAdd;
            if (!identifier) {
              return;
            }

            addMonittaProductToVintage(identifier);
          });
        }

        if (vintageList) {
          vintageList.addEventListener("click", (event) => {
            const target = event.target;
            if (!target || !(target instanceof HTMLElement)) {
              return;
            }

            if (!target.matches("button[data-vintage-remove]")) {
              return;
            }

            const { vintageRemove } = target.dataset;
            if (typeof vintageRemove === "undefined") {
              return;
            }

            removeVintageProductAtIndex(vintageRemove);
          });
        }

        const renderVintageProducts = () => {
          if (!vintageList) {
            return;
          }

          vintageList.innerHTML = "";

          if (!Array.isArray(editableVintageProducts) || editableVintageProducts.length === 0) {
            const empty = document.createElement("li");
            empty.className = "placeholder";
            empty.textContent = "Brak powiązanych produktów vintage.";
            vintageList.appendChild(empty);
            return;
          }

          editableVintageProducts.forEach((item, index) => {
            const listItem = document.createElement("li");
            listItem.className = "vintage-item";
            listItem.dataset.vintageIndex = String(index);

            const header = document.createElement("div");
            header.className = "vintage-item__header";

            const titleValue = resolveField(
              item,
              [
                "name",
                "title",
                "productName",
                "label",
                "VintageProductName",
                "vintageProductName",
              ],
              `Produkt ${index + 1}`
            );
            const titleText = toDisplayString(titleValue);
            const url = resolveField(item, [
              "url",
              "link",
              "productUrl",
              "href",
              "VintageProductUrl",
              "vintageProductUrl",
            ]);

            if (url) {
              const anchor = document.createElement("a");
              anchor.href = url;
              anchor.target = "_blank";
              anchor.rel = "noopener";
              anchor.textContent = titleText;
              header.appendChild(anchor);
            } else {
              const nameElement = document.createElement("strong");
              nameElement.textContent = titleText;
              header.appendChild(nameElement);
            }

            const removeButton = document.createElement("button");
            removeButton.type = "button";
            removeButton.className = "vintage-remove";
            removeButton.dataset.vintageRemove = String(index);
            removeButton.textContent = "Usuń";
            header.appendChild(removeButton);

            const price = resolveField(item, ["price", "amount", "value"]);
            const currency = resolveField(
              item,
              ["currency", "currencyCode", "priceCurrency"],
              ""
            );
            const description = resolveField(item, ["description", "summary", "details"]);

            const body = document.createElement("div");
            body.className = "vintage-item__body";

            const imageUrl = resolveVintageImageUrl(item);
            if (imageUrl) {
              const image = document.createElement("img");
              image.className = "vintage-item__image";
              image.src = imageUrl;
              image.loading = "lazy";
              image.decoding = "async";
              const altTitle = toDisplayString(titleText ?? "").trim();
              image.alt = altTitle
                ? `Zdjęcie ${altTitle}`
                : "Zdjęcie produktu vintage";
              body.appendChild(image);
            }

            const textWrapper = document.createElement("div");
            textWrapper.className = "vintage-item__content";
            textWrapper.appendChild(header);

            const details = document.createElement("div");
            details.className = "vintage-item__details";

            if (price) {
              const priceElement = document.createElement("small");
              priceElement.textContent = currency ? `${price} ${currency}` : `${price}`;
              details.appendChild(priceElement);
            }

            if (description) {
              const descriptionElement = document.createElement("p");
              descriptionElement.textContent = description;
              descriptionElement.style.margin = "0";
              descriptionElement.style.color = "#4b5563";
              details.appendChild(descriptionElement);
            }

            if (details.children.length > 0) {
              textWrapper.appendChild(details);
            }

            body.appendChild(textWrapper);
            listItem.appendChild(body);

            vintageList.appendChild(listItem);
          });
        };

        const removeVintageProductAtIndex = (index) => {
          if (!Array.isArray(editableVintageProducts)) {
            return;
          }

          const normalizedIndex = Number(index);
          if (
            Number.isNaN(normalizedIndex) ||
            normalizedIndex < 0 ||
            normalizedIndex >= editableVintageProducts.length
          ) {
            return;
          }

          const [removed] = editableVintageProducts.splice(normalizedIndex, 1);
          syncEditableVintageToProduct();

          const identifier = getVintageProductIdentifier(removed);
          if (identifier) {
            monittaState.selectedMap.delete(identifier);
          }

          updateMonittaSelectionInProduct();
          setEditableVintageFromProduct(currentProduct);
          renderVintageProducts();
          renderMonittaList();
          updateMonittaCount();
          updateSaveButtonState();
        };

        const addMonittaProductToVintage = (identifier) => {
          if (!identifier || !currentProduct) {
            return;
          }

          if (monittaState.selectedMap.has(identifier)) {
            return;
          }

          const datasetEntry = monittaState.allProductsMap.get(identifier);
          const fallbackEntry = datasetEntry ?? createMonittaEntry({ id: identifier });
          if (!fallbackEntry) {
            return;
          }

          const existing = monittaState.selectedMap.get(identifier) ?? null;
          const entry = duplicateMonittaEntry(fallbackEntry, existing);
          if (!entry) {
            return;
          }

          monittaState.selectedMap.set(identifier, entry);
          syncEditableVintageToProduct();
          updateMonittaSelectionInProduct();
          setEditableVintageFromProduct(currentProduct);
          renderVintageProducts();
          renderMonittaList();
          updateMonittaCount();
          updateSaveButtonState();
        };

        const populateForm = (product) => {
          const safeProduct = product && typeof product === "object" ? product : {};

          const resolvedName = resolveField(
            safeProduct,
            ["name", "title", "productName", "label"],
            ""
          );
          if (nameInput) {
            nameInput.value = toDisplayString(resolvedName);
          }

          const resolvedDescription = resolveField(
            safeProduct,
            ["description", "summary", "details", "productDescription"],
            ""
          );
          if (descriptionInput) {
            descriptionInput.value = toDisplayString(resolvedDescription);
          }

          setEditableImagesFromProduct(safeProduct);
          renderImages();
          setEditableVintageFromProduct(safeProduct);
          renderVintageProducts();
          setMonittaSelectedFromProduct(safeProduct);

          if (newImagesInput) {
            newImagesInput.value = "";
          }
          renderSelectedImages(newImagesInput?.files ?? []);

          const nameForTitle = nameInput ? nameInput.value.trim() : "";
          document.title = nameForTitle
            ? `${nameForTitle} — Edycja produktu`
            : "Edycja produktu";
        };

        const assignProduct = (product) => {
          const normalized = normalizeProduct(product, productId);
          currentProduct = cloneProduct(normalized ?? product);
          populateForm(currentProduct);

          if (form) {
            form.hidden = false;
          }

          updateSaveButtonState();
        };

        const fetchProductDetails = async () => {
          if (!productId) {
            throw new Error("Brak identyfikatora produktu.");
          }

          const endpoint = `${apiBaseUrl}/${encodeURIComponent(productId)}`;
          const response = await fetch(endpoint);

          if (!response.ok) {
            throw new Error(`Żądanie nie powiodło się. Kod odpowiedzi: ${response.status}`);
          }

          const product = await response.json();

          if (!product || typeof product !== "object") {
            throw new Error("Serwer zwrócił nieoczekiwany format danych.");
          }

          const normalized = normalizeProduct(product, productId);
          if (!normalized) {
            throw new Error("Odebrano nieprawidłowe dane produktu.");
          }

          return normalized;
        };

        const buildUpdatePayload = () => {
          if (!currentProduct || typeof currentProduct !== "object") {
            return null;
          }

          const draft = cloneProduct(currentProduct);
          assignImagesToTarget(draft, editableImages);
          assignVintageProductsToTarget(draft, editableVintageProducts);
          const sanitizedName = nameInput ? nameInput.value.trim() : "";
          const sanitizedDescription = descriptionInput ? descriptionInput.value.trim() : "";

          updateKnownFields(draft, ["Name", "name", "title", "productName", "label"], sanitizedName);
          updateKnownFields(
            draft,
            ["Description", "description", "summary", "details", "productDescription"],
            sanitizedDescription
          );
          ensureIdentifier(draft);

          updateKnownFields(
            currentProduct,
            ["Name", "name", "title", "productName", "label"],
            sanitizedName
          );
          updateKnownFields(
            currentProduct,
            ["Description", "description", "summary", "details", "productDescription"],
            sanitizedDescription
          );
          ensureIdentifier(currentProduct);

          const previousIdentifierValues = [];
          [
            draft?.monittaStoreProducts,
            draft?.monittaStoreProductIds,
            draft?.monittaProducts,
            draft?.monittaProductIds,
            draft?.monittaStoreItems,
            draft?.monittaIds,
          ].forEach((source) => {
            previousIdentifierValues.push(...toArray(source));
          });
          const previousIdentifiers = gatherNormalizedMonittaIdentifierSet(previousIdentifierValues);

          const monittaProductsSource = getMonittaPayload();
          const sanitizedMonittaProducts = sanitizeMonittaEntries(monittaProductsSource);
          const monittaIdentifiers = gatherMonittaIdentifiers(sanitizedMonittaProducts);

          assignMonittaProductsToTarget(draft, sanitizedMonittaProducts);
          assignMonittaIdentifiersToTarget(draft, monittaIdentifiers);
          mergeMonittaIntoVintageProducts(draft, sanitizedMonittaProducts, previousIdentifiers);

          assignMonittaProductsToTarget(currentProduct, sanitizedMonittaProducts);
          assignMonittaIdentifiersToTarget(currentProduct, monittaIdentifiers);
          mergeMonittaIntoVintageProducts(currentProduct, sanitizedMonittaProducts, previousIdentifiers);

          const idCandidate = resolveField(
            draft,
            ["id", "Id", "ID", "productId", "productID"],
            productId ?? ""
          );
          const normalizedId = toDisplayString(idCandidate).trim();

          const resolvedName = toDisplayString(
            resolveField(
              draft,
              ["Name", "name", "title", "productName", "label"],
              sanitizedName
            )
          ).trim();

          const resolvedDescription = toDisplayString(
            resolveField(
              draft,
              ["Description", "description", "summary", "details", "productDescription"],
              sanitizedDescription
            )
          ).trim();

          const imagesForPayload = gatherImagesForPayload(
            draft?.Images,
            draft?.images,
            draft?.image,
            draft?.photos,
            editableImages
          );

          const vintageEntriesForPayload = sanitizeVintageProductsForPayload(
            getExistingVintageProducts(draft)
          );

          return {
            id: normalizedId || (productId ? String(productId).trim() : ""),
            Name: resolvedName,
            Description: resolvedDescription,
            Images: imagesForPayload,
            VintageProducts: vintageEntriesForPayload,
          };
        };

        const uploadProductImages = async (id, files) => {
          if (!id || !Array.isArray(files) || files.length === 0) {
            return null;
          }

          if (typeof FormData === "undefined") {
            throw new Error("Przesyłanie zdjęć nie jest obsługiwane w tej przeglądarce.");
          }

          const formData = new FormData();
          files.forEach((file, index) => {
            if (!file) {
              return;
            }

            const fallbackName = `image-${index + 1}`;
            const fileName = file.name && file.name.trim() ? file.name : fallbackName;
            formData.append("files", file, fileName);
          });

          const uploadEndpoint = `${uploadBaseUrl}/${encodeURIComponent(id)}`;
          const response = await fetch(uploadEndpoint, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(
              `Żądanie przesłania zdjęć nie powiodło się. Kod odpowiedzi: ${response.status}`
            );
          }

          try {
            return await response.json();
          } catch (error) {
            return null;
          }
        };

        const saveProduct = async () => {
          if (isSaving) {
            return;
          }

          if (!productId) {
            setStatus(
              "Brak identyfikatora produktu. Upewnij się, że adres URL zawiera parametr ?productID=…",
              "error"
            );
            return;
          }

          if (!currentProduct || !hasProductData(currentProduct)) {
            setStatus("Brak danych produktu do zapisania.", "error");
            return;
          }

          if (form && typeof form.reportValidity === "function" && !form.reportValidity()) {
            return;
          }

          const payload = buildUpdatePayload();

          if (!payload) {
            setStatus("Nie udało się przygotować danych produktu do zapisu.", "error");
            return;
          }

          const selectedFiles = getSelectedImageFiles();

          setSavingState(true);
          setStatus("Trwa zapisywanie zmian produktu…");

          try {
            const endpoint = `${apiBaseUrl}/${encodeURIComponent(productId)}`;
            const response = await fetch(endpoint, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              throw new Error(`Żądanie nie powiodło się. Kod odpowiedzi: ${response.status}`);
            }

            let updatedProduct = null;
            try {
              updatedProduct = await response.json();
            } catch (error) {
              updatedProduct = null;
            }

            if (updatedProduct && typeof updatedProduct === "object") {
              const normalizedUpdate = normalizeProduct(updatedProduct, productId);
              assignProduct(normalizedUpdate ?? updatedProduct);
            } else {
              try {
                const refreshed = await fetchProductDetails();
                assignProduct(refreshed);
              } catch (refreshError) {
                console.error("Błąd podczas odświeżania danych produktu:", refreshError);
                assignProduct(payload);
              }
            }

            if (selectedFiles.length > 0) {
              setStatus(
                "Zmiany produktu zostały zapisane. Trwa przesyłanie wybranych zdjęć…"
              );

              try {
                const refreshedProduct = await uploadProductImages(productId, selectedFiles);

                if (refreshedProduct && typeof refreshedProduct === "object") {
                  const normalizedRefreshed = normalizeProduct(
                    refreshedProduct,
                    productId,
                  );
                  assignProduct(normalizedRefreshed ?? refreshedProduct);
                  setStatus("Zmiany produktu oraz zdjęcia zostały zapisane.", "success");
                } else {
                  setStatus(
                    "Zmiany produktu zostały zapisane, ale nie udało się odświeżyć danych po przesłaniu zdjęć.",
                    "error"
                  );
                }
              } catch (uploadError) {
                console.error("Błąd podczas przesyłania zdjęć produktu:", uploadError);
                setStatus(
                  "Zmiany produktu zostały zapisane, ale nie udało się przesłać nowych zdjęć.",
                  "error"
                );
              }
            } else {
              setStatus("Zmiany produktu zostały zapisane.", "success");
            }
          } catch (error) {
            console.error("Błąd podczas zapisywania produktu:", error);
            setStatus(
              "Nie udało się zapisać zmian produktu. Spróbuj ponownie.",
              "error"
            );
          } finally {
            setSavingState(false);
          }
        };

        const loadProduct = async () => {
          if (!productId) {
            setStatus(
              "Brak identyfikatora produktu w adresie URL. Użyj parametru ?productID=…",
              "error"
            );

            if (form) {
              form.hidden = true;
            }

            currentProduct = null;
            updateSaveButtonState();

            editableImages = [];
            renderImages();
            editableVintageProducts = [];
            renderVintageProducts();
            setMonittaSelectedFromProduct({});
            if (newImagesInput) {
              newImagesInput.value = "";
            }
            renderSelectedImages(newImagesInput?.files ?? []);
            document.title = "Edycja produktu";
            return;
          }

          setStatus("Trwa wczytywanie danych produktu…");

          try {
            const product = await fetchProductDetails();
            assignProduct(product);
            setStatus("Dane produktu zostały pomyślnie wczytane.", "success");
          } catch (error) {
            console.error("Błąd podczas wczytywania danych produktu:", error);
            setStatus(
              "Nie udało się wczytać szczegółów produktu. Upewnij się, że podany identyfikator jest poprawny.",
              "error"
            );

            editableImages = [];
            renderImages();
            editableVintageProducts = [];
            renderVintageProducts();
            setMonittaSelectedFromProduct({});
            if (newImagesInput) {
              newImagesInput.value = "";
            }
            renderSelectedImages(newImagesInput?.files ?? []);
            document.title = "Edycja produktu";

            currentProduct = null;
            if (form) {
              form.hidden = true;
            }
            updateSaveButtonState();
          }
        };

        if (saveButton) {
          saveButton.addEventListener("click", saveProduct);
        }

        renderMonittaList();
        updateMonittaCount();
        loadMonittaProducts();

        loadProduct();
      })();
    </script>
  </body>
</html>
